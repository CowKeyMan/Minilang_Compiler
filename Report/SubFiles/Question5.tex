\section{Task 5 - Interpretation}
\subsection{Explanation and Implementation}
The interpreter is to execute the program line by line and report any run time errors if there are any. The symbol table is regenerated and this time it will contain identifiers and their contents besides just their types. This content will also be changed as the program executes.

A new visitor class was created called \textit{IVIsitor}, which contains the following items:

\begin{lstlisting}
vector<map<string, ValueType>> scope;
void newScope(); // add scope as the 0 index of the vector
void insert(string, ValueType); // in current scope
void removeScope(); // remove scope at position 0
ValueType lookup(string); // lookup starting from vector 0 and going down
// a map, mapping function names to wherever the function is
map <string, ASTNode*> functions;
int lineNumber = 0;

bool performFunction = true;
vector<ValueType> 
bool returnFromFunction = false;
ValueType returnValue;
\end{lstlisting}
ValueType is a struct which was created for this visitor:
\begin{lstlisting}
struct ValueType{
	void* value;
	TokenType type; //bool, int or float (needed for conversion)
};
\end{lstlisting}

\textit{performFunction} is used to determine whether a function is currently being declared or performed. \textit{parameters} is used to store the values of the parameters as they are sent to a function. \textit{returnFromFunction} is set to true when a return is found, and is not set back to false until a function call ends (or the program terminates). While it is true, no statement or block is executed. \textit{returnValue} is set to something by the return statement, and set back to null after a function returns.

Next, the functionality of each node is discussed:
\begin{itemize}
	\item Type : TokenType
		\subitem returns FLOAT, INT or BOOL(the type) depending on its token
	\item Literal : Value
		\subitem The value of the literal is returned
	\item Identifier : string (the lexeme of the identifier token)
		\subitem returns name of the identifier. Lookup for value is handled by parent node
	\item MultiplicativeOp : MultOp Type (ex. TIMES, AND)
		\subitem returns the operator itself, so that the expression node it belongs to can use it to operate on the values
	\item AdditiveOp : AddOp Token (ex. PLUS, OR)
		\subitem Very similar to MultiplicativeOp but with Additive operators
	\item RelationalOp : Type (ex. EQQ, ST)
		\subitem Very similar to MultiplicativeOp but with Relational operators
	\item ActualParams : Vector of Values
		\subitem gets value from each parameter and returns their vector
	\item FunctionCall : Value
		\subitem sets \textit{performFunction} to true
		\subitem sets the \textit{parameters} value to the values returned from the actual parameters
		\subitem gets function from \textit{functions} map and traverses it until a return is found
		\subitem resets the parameters value
		\subitem resets the \textit{returnValue} variable and returns it's previous value
	\item SubExpression : Value
		\subitem returns value of the containing expression
	\item Unary : Value
		\subitem applies the unary operator
		\subitem returns the value after application
	\item Factor : Value
		\subitem returns value of containing factor
		\subitem if it is an ID, looks it up in scope table
	\item Term : Value
		\subitem applies the operator
		\subitem returns the value after application
	\item SimpleExpression : Value
		\subitem applies the operator
		\subitem returns the value after application
	\item Expression : Value
		\subitem applies the operator
		\subitem returns the value after application
	\item Assignment : void
		\subitem change value of item in symbol table
	\item VariableDecl : void
		\subitem Add item to symbol table
	\item PrintStatement : void
		\subitem print given expression to screen (including a new line)
	\item ReturnStatement : void
		\subitem sets the \textit{returnValue} variable to the expression
		\subitem sets the \textit{returnFromFunction} variable to true, so that nothing is computed until the program exits the function
	\item IfStatement : void
		\subitem computes the given expression
		\subitem if true, opens new scope, visits the if-block, closes scope
		\subitem if false, and an else-block exists, then opens new scope, the else block is visited, closes scope
	\item ForStatement : void
		\subitem performs variable declaration
		\subitem start new scope, visit the block, end scope
		\subitem performs variable assignment
		\subitem checks expression and exits if it is false, otherwise repeats block
	\item FormalParam : string
		\subitem returns name of parameter
	\item FormalParams : Vector of strings
		\subitem returns all the names of the parameters
	\item FunctionDecl : void, Value
		\subitem If \textit{performFunction} is false, simply add the function to the \textit{functions} map
		\subitem If \textit{performFunction} is true, open new scope, assign the variables to the given parameters, traverse trough function block, close block, set \textit{returnFromFunction} to false, return the returnValue.
	\item Statement : void
		\subitem visits the statement
		\subitem if is is a block, start ne scope, visit block, end scope
	\item Block
		\subitem unless \textit{returnFromFunction} is set to true, iterate trough the statements, until \textit{returnFromFunction} is set to true
	\item Program
		\subitem iterates trough all statements until the end, or until \textit{returnFromFunction} is set to true
\end{itemize}

Some thing to note about the interpreter:
\begin{itemize}
	\item The only runtime error that can occur is division by zero, which is reported to the user if it is found.
	\item The program itself can return a value, if a return statement is found outside a function declaration, otherwise, it returns with NULL.
	\item 3/2 is 1.5, not 1, because everything (including booleans) is treated as a float. However, if the statement:
	\begin{center}var x : int = 3/2 \end{center}
	is found, it is valid but x is set to 1. This approach was taken to allow as much functionality as possible, while avoiding certain ambiguities like how C/C++ says that 3/2 is 1, so you'd need to instead write 3.0/2 or 3/2.0 to get the proper 1.5.
\end{itemize}

\subsection{Example Tests}
For this section please take a look at the showcase video at \url{https://www.youtube.com/watch?v=kv1VEmtuk6E} or try out the sample input files provided. It includes examples with errors and their corresponding error reporting and fixes, as well as more concrete examples, with proper outputs.