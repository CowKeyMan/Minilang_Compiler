\section{Task 4 - Semantic Analysis}
\subsection{Explanation and Implementation}
The task of the semantic analysis is to perform type checking and scope checking by traversing the AST and making the required checks at each node.

In order to achieve this, a new visitor inherited class was created called \textit{SAVisitor}. It contains the following functionality and data in order to perform its job (as well as the visit methods).

\begin{lstlisting}[language=C++]
 vector<map<string, TokenType>> scope;
void newScope(); // add scope as the 0 index of the vector
void insert(string, TokenType); // in current scope
void removeScope(); // remove scope at position 0
// set as pointer to TokenType due to the need to make it return null
TokenType* lookup(string); // lookup starting from vector 0 and going down
// a map, mapping function names to their parameter types
map <string, vector<TokenType> > functions; 
TokenType *currentFunctionType = nullptr;
int lineNumber = 0;

// Methods to help determine if a function has a proper return statement in all paths
bool insideFor = false; // do nothing while inside for
bool insideFunction = false; // only applies if inside function
vector<bool> ifsReturn;
int ifsReturnIndex = -1;
bool goodReturn;
\end{lstlisting}

The scope vector is treated like a stack, but created as a vector to be iterated over easily. New entries are inserted at the front (position 0) of the vector and same thing with deletions. When iterating, iteration also starts from the front, so new entries cover shadow old ones (scope shadowing). The scope together with the functions map, together make the symbol table.
\\\\
Next, the visit classes are discussed. Each one of these, although described as a \textit{void*}, has some form of concrete return value, and not all of them are the same. The functionality of each method and their return type is discussed below, for each type of ASTNode visit method:
\begin{itemize}
	\item Type : Type 
		\subitem returns FLOAT, INT or BOOL(the type) depending on its token
	\item Literal : Type
		\subitem returns the type of its literal value
	\item Identifier : string (the lexeme of the identifier token)
		\subitem returns name of the identifier. Lookup is handled by parent node
	\item MultiplicativeOp : MultOp Type (ex. TIMES, AND)
		\subitem returns the operator itself, so that the expression node it belongs to can check that the operator supports the types it is operating upon. (Ex. "7*8" is valid, but "7 and 8" is not)
	\item AdditiveOp : AddOp Type (ex. PLUS, OR)
		\subitem very similar to MultiplicativeOp but with different operators
	\item RelationalOp : RelOp Type (ex. EQQ, ST)
		\subitem very similar to MultiplicativeOp but with different operators
	\item ActualParams : Vector of Type
		\subitem iterates through all the parameters and returns a vector of all their types, so they can be matched with the formal parameters by the FunctionDecl node.
	\item FunctionCall : Type
		\subitem validates the function exists
		\subitem validates the parameters provided are of the required type
		\subitem If any of these are false, the required errors are reported and program exits
	\item SubExpression : Type
		\subitem returns the type of the expression it has
	\item Unary : Type
		\subitem validates that the unary operator is applied on the proper type and returns the type of the expression
	\item Factor : Type
		\subitem returns the type of its node
	\item Term : Type
		\subitem validates that any operators are being used properly and are of the correct type
	\item SimpleExpression : Type
		\subitem validates that any operators are being used properly and are of the correct type (ex. "4*6.8" returns float, while 9*true gives an error)
		\subitem very similar to Term but with additive operators instead
	\item Expression : Type
		\subitem very similar to Term and Simple but with relational operators instead
	\item Assignment : void
		\subitem validates the identifier exists
		\subitem validates the identifier's type and type of expression match
	\item VariableDecl : void
		\subitem makes sure that the types of the given type and expression are not conflicting
		\subitem adds the identifier to the symbol table, with the given type. Error if it already exists
	\item PrintStatement : void
		\subitem verify the given expression is correct
	\item ReturnStatement : void
		\subitem makes sure that the type of the expression also matches the type of the current function it is within by using the \textit{currentFunctionType} variable.
	\item IfStatement : void
		\subitem validates that expression is of type bool
		\subitem start new scope
		\subitem validates block
		\subitem pop scope
		\subitem validates else block if it exists (while creating and popping scopes)
	\item ForStatement : void
		\subitem creates new scope
		\subitem Performs and validates the variable declaration
		\subitem validates that expression is of type bool
		\subitem validates assignment
		\subitem validates block
		\subitem pops scope
	\item FormalParam : Type
		\subitem put each paramater in the current symbol table
		\subitem returns type of parameter
	\item FormalParams : Vector of Type
		\subitem iterates trough each FormalParam declaration adding them to the vector
	\item FunctionDecl : void
		\subitem add function to the functionParams map after starting new scope and  validating the FormalParams(Note: they are added in the scope within their own methods)
		\subitem set the currentFunctionType to the type of the function so ReturnStatement can know
		Add function to symbol table after validating size of symbol table is one (outer scope)
		\subitem validate the Block
		\subitem close scope
	\item Statement : void
		\subitem validate the statement
		\subitem if block, then start new scope
	\item Block : void
		\subitem validate the list of statements
	\item Program : void
		\subitem validate the list of statements. Starts with function declarations.
\end{itemize}

Note: scopes were not started and ended in the 'Block' node because of function declarations.

\subsubsection{Semantic Analysis Features}
This section is to discuss some features including additional extras in the semantic analyser implementation
\\\\
The first feature is that error reporting includes precise errors as well as the included line number where the error occurred. This was made by having a global line number variable and updating it every time a node with a token is visited.
\\\\
Second extra feature is that type conversion from integers to floats is made available. So float types can accept integers, however integers cannot accept floats. This was made trough type checking.
\\\\
The program is allowed to exit abruptly, hence why return statements can be accepted from outside a function.
\\\\
A function declaration is checked to make sure \textbf{all code paths return a proper value}. This means that if a return exists in an if, but no corresponding return in an else or outside the if statement exists, the function is declared semantically incorrect. Returns in for loops are also not considered to be enough for a function to be valid for the semantic analyser. This was made possible trough the use of a stack and a few global variables, in conjunction with checks when returns are made inside of functions.
\\\\
Important to note is that function names cannot be overridden anywhere in the code.
\\\\
Functions can only be defined in the outer scope
\\\\ Functions can be used before they are declared, because their declaration is performed first. Hence no other variable anywhere in the program may use the function's name.

\subsection{Example Tests}


Given the following code, the semantic analyser returns that it is valid
\begin{lstlisting}[language=C]
print 5;
\end{lstlisting}

However, while the parser can successfully parse the following, the semantic analyser does not find x in the table:
\begin{lstlisting}[language=C]
return x;
\end{lstlisting}
So the semantic analyser complains by saying:
\begin{lstlisting}[numbers=none]
Identifier x at line 1 does not exist
\end{lstlisting}

The following is a function declaration, note how it is defined badly, because if the code goes to the scope where the comment resides, then it would return null, which is not a supported type
\begin{lstlisting}[language=C]
fn u():bool{
	if(4>6){
		return true;
	}else{
		if(5>6){
			return true;
		}else{
			//return true;
		}
	}
}
\end{lstlisting}
and the compiler complains:
\begin{lstlisting}[numbers=none]
Function u at line number 1: not all code paths return a value
\end{lstlisting}
This could be remedied by uncommenting the comment.
\\\\
More items which are checked are correct type and amount of parameters to functions as well as that return statements are of the correct type when inside a function.